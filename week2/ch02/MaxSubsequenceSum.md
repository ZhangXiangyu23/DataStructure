### 最大子序列问题

#### 算法一：穷举法

时间复杂度为O(N^3)

思路：第一个for循环控制子序列的左边界，第二个for循环控制子序列的右边界。前两个for循环将全部的子序列进行穷举，最后一个for循环进行每个子序列和的计算。

优点：思路明确，容易想到。

缺点：时间复杂度大，很多子序列的计算都做了重复计算，耗时大。

#### 算法二：对穷举法进行优化，可以优化掉一个for循环

时间复杂度为O(N^2)

思路：第一个for循环控制左边界，第二个for循环控制右边界，优化第三个for循环。在第二个for循环内就进行子序列和的计算（累计），避免像算法一一样，做很多次重复的计算。

#### 算法三：利用“分治”的思想+递归，进行求解

时间复杂度为O(NlogN)

思路：以中间为界，最大子序列可能存在：（1）左侧（2）右侧（3）跨越中间的左右侧之和

分别进行计算：然后比较之和，返回最大序列和

（1）左侧，利用递归求只在左侧的最大子序列和

（2）右侧，同左侧一样，利用递归求只在右侧的最大子序列和

（3）跨越中间的左右侧之和，从中间界限开始，往左求连接中间的左侧最大子序列和；往右求连接中间的右侧最大子序列和；

然后将两侧的和进行相加，便是跨越中间的左右侧之和。

最后看看哪种情况是最大的，返回即可。

缺点：有点绕，思路难想到，不好实现。

优点：时间复杂度小，效率较好。

#### 算法四：联机算法

时间复杂度为：O(N)

思路：从左往右扫描，算每个连着的子序列，如果子序列大于0（有可能成为最大子序列和），先放在ThisSum中，待定。如果ThisSum比当前的MaxSum还大，替换MaxSum。如果小于0，毫无可能连起来成为最大子序列，将ThisSum置为0.

优点：线性的时间复杂度，效率高

缺点：emmm,不好想吧！

